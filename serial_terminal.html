<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>lib/serial_terminal.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel='stylesheet' href='./style.css' />
</head>

<body>



<ul id="index"><li><a href="./index.html"><i>&lt;= Back to file list</i></a></li>
  <li>
    <ul>
      <li><a href="#add_serial_console">add_serial_console</a></li>
      <li><a href="#prepare_serial_console">prepare_serial_console</a></li>
      <li><a href="#get_login_message">get_login_message</a></li>
      <li><a href="#set_serial_prompt">set_serial_prompt</a></li>
      <li><a href="#login">login</a></li>
      <li><a href="#download_file">download_file</a></li>
      <li><a href="#upload_file-upload_file-src-dst-chunk_size-cz-chunk_retry-cr">upload_file upload_file($src, $dst, [, chunk_size =&gt; $cz][, chunk_retry =&gt; $cr]);</a></li>
      <li><a href="#select_serial_terminal">select_serial_terminal</a></li>
      <li><a href="#select_user_serial_terminal">select_user_serial_terminal</a></li>
    </ul>
  </li>
</ul><h1>lib/serial_terminal.pm</h1>

<h2 id="add_serial_console">add_serial_console</h2>

<pre><code>add_serial_console($console);</code></pre>

<p>Adds $console to /etc/securetty (unless already in file), enables systemd service and start it. It requires selecting root console before.</p>

<h2 id="prepare_serial_console">prepare_serial_console</h2>

<pre><code>prepare_serial_console();</code></pre>

<p>Wrapper for add_serial_console.</p>

<p>Configure serial consoles for virtio support (root-virtio-terminal and user-virtio-terminal).</p>

<p>NOTE: if test plans to use more consoles via VIRTIO_CONSOLE_NUM, it have to call add_serial_console() with proper console name (beware different number for ppc64le).</p>

<h2 id="get_login_message">get_login_message</h2>

<pre><code>get_login_message();</code></pre>

<p>Get login message printed by OS at the end of the boot. Suitable for testing whether boot has been finished:</p>

<p>wait_serial(get_login_message(), 300);</p>

<h2 id="set_serial_prompt">set_serial_prompt</h2>

<pre><code>set_serial_prompt($user);</code></pre>

<p>Set serial terminal prompt to given string.</p>

<h2 id="login">login</h2>

<pre><code>login($user);</code></pre>

<p>Enters root&#39;s name and password to login. Also sets the prompt to something static without ANSI escape sequences (i.e. a single #) and changes the terminal width.</p>

<h2 id="download_file">download_file</h2>

<pre><code>download_file($src, $dst [, force =&gt; $force][, chunk_size =&gt; $cz][, chunk_retry =&gt; $cr])</code></pre>

<p>Download a file from worker to SUT using the current serial terminal. The file is split into chunks <code>chunk_size</code> and each chunk is verified with checksum. If a chunk fails, the upload will be retried up to <code>chunk_retry</code> times, before giving up. To overwrite destination use <code>force</code>. This function die on any failure.</p>

<h2 id="upload_file-upload_file-src-dst-chunk_size-cz-chunk_retry-cr">upload_file upload_file($src, $dst, [, chunk_size =&gt; $cz][, chunk_retry =&gt; $cr]);</h2>

<p>Upload a file from SUT to the worker using the current serial terminal. The file is parted into chunks <code>chunk_size</code> and each chunk gets is verified with checksum. If a chunk fail we retry it <code>chunk_retry</code> times, before give up. The file is placed in the <code>ulogs/</code> directory of the worker.</p>

<p>This function die on any failure.</p>

<h2 id="select_serial_terminal">select_serial_terminal</h2>

<pre><code>select_serial_terminal($root[, $prompt]);</code></pre>

<p>Select most suitable text console. The optional parameter <code>root</code> controls whether the console will have root privileges or not. Passing any value that evaluates to true will select a root console (default). Passing any value that evaluates to false will select unprivileged user console. The choice is made by BACKEND and other variables.</p>

<p>Purpose of this wrapper is to avoid if/else conditions when selecting console.</p>

<p>Optional <code>root</code> parameter specifies, whether use root user (<code>root</code>=1, also default when parameter not specified) or prefer non-root user if available.</p>

<p>Variables affecting behavior: <code>VIRTIO_CONSOLE</code>=0 disables virtio console (use {root,user}-console instead of the default {root-,user-}virtio-terminal) NOTE: virtio console is enabled by default (<code>VIRTIO_CONSOLE</code>=1). For ppc64le it requires to call prepare_serial_console() to before first use (used in console/system_prepare and shutdown/cleanup_before_shutdown modules) and console=hvc0 in kernel parameters (add it to autoyast profile or update grub setup manually with add_grub_cmdline_settings()).</p>

<p><code>SERIAL_CONSOLE</code>=0 disables serial console (use {root,user}-console instead of the default {root-,}sut-serial) NOTE: serial console is disabled by default on all but s390x machines (<code>SERIAL_CONSOLE</code>=0), because it&#39;s not working yet on other machines (see poo#55985). For s390x it requires console=ttysclp0 in kernel parameters (add it to autoyast profile or update grub setup manually with add_grub_cmdline_settings()).</p>

<p>On ikvm|ipmi|spvm|pvm_hmc it&#39;s expected, that use_ssh_serial_console() has been called (done via activate_console()) therefore SERIALDEV has been set and we can use root-ssh console directly.</p>

<h2 id="select_user_serial_terminal">select_user_serial_terminal</h2>

<pre><code>select_user_serial_terminal([$prompt]);</code></pre>

<p>Select most suitable text console with non-root user. The choice is made by BACKEND and other variables.</p>


</body>

</html>


