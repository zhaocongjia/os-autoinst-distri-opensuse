<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>lib/opensusebasetest.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel='stylesheet' href='./style.css' />
</head>

<body>



<ul id="index"><li><a href="./index.html"><i>&lt;= Back to file list</i></a></li>
  <li>
    <ul>
      <li><a href="#clear_and_verify_console">clear_and_verify_console</a></li>
      <li><a href="#pre_run_hook">pre_run_hook</a></li>
      <li><a href="#post_run_hook">post_run_hook</a></li>
      <li><a href="#investigate_yast2_failure">investigate_yast2_failure</a></li>
      <li><a href="#export_logs_locale">export_logs_locale</a></li>
      <li><a href="#upload_packagekit_logs">upload_packagekit_logs</a></li>
      <li><a href="#set_standard_prompt">set_standard_prompt</a></li>
      <li><a href="#handle_uefi_boot_disk_workaround">handle_uefi_boot_disk_workaround</a></li>
      <li><a href="#wait_grub">wait_grub</a></li>
      <li><a href="#wait_grub_to_boot_on_local_disk">wait_grub_to_boot_on_local_disk</a></li>
      <li><a href="#handle_pxeboot">handle_pxeboot</a></li>
      <li><a href="#wait_boot_past_bootloader">wait_boot_past_bootloader</a></li>
      <li><a href="#wait_boot">wait_boot</a></li>
      <li><a href="#enter_test_text">enter_test_text</a></li>
      <li><a href="#firewall">firewall</a></li>
      <li><a href="#post_fail_hook">post_fail_hook</a></li>
    </ul>
  </li>
</ul><h1>lib/opensusebasetest.pm</h1>

<h2 id="clear_and_verify_console">clear_and_verify_console</h2>

<pre><code>clear_and_verify_console();</code></pre>

<p>Clear the console and ensure that it really got cleared using a needle.</p>

<h2 id="pre_run_hook">pre_run_hook</h2>

<pre><code>pre_run_hook();</code></pre>

<p>This method will be called before each module is executed. Test modules (or their intermediate base classes) may overwrite this method, must call this baseclass method from the overwriting method.</p>

<h2 id="post_run_hook">post_run_hook</h2>

<pre><code>post_run_hook();</code></pre>

<p>This method will be called after each module finished. It will <b>not</b> get executed when the test module failed. Test modules (or their intermediate base classes) may overwrite this method.</p>

<h2 id="investigate_yast2_failure">investigate_yast2_failure</h2>

<pre><code>investigate_yast2_failure(logs_path =&gt; $logs_path);</code></pre>

<p>Inspect the YaST2 logfile checking for known issues. logs_path can be a directory where logs are saved e.g. /tmp. In that case the function will parse /tmp/var/log/YaST2/y2logs* files.</p>

<h2 id="export_logs_locale">export_logs_locale</h2>

<pre><code>export_logs_locale();</code></pre>

<p>Upload logs related to system locale settings. This includes <code>locale</code>, <code>localectl</code> and <code>/etc/vconsole.conf</code>.</p>

<h2 id="upload_packagekit_logs">upload_packagekit_logs</h2>

<pre><code>upload_packagekit_logs();</code></pre>

<p>Upload <code>/var/log/pk_backend_zypp</code>.</p>

<h2 id="set_standard_prompt">set_standard_prompt</h2>

<pre><code>set_standard_prompt();</code></pre>

<p>Set a simple reproducible prompt for easier needle matching without hostname.</p>

<h2 id="handle_uefi_boot_disk_workaround">handle_uefi_boot_disk_workaround</h2>

<pre><code>handle_uefi_boot_disk_workaround();</code></pre>

<p>Our aarch64 setup fails to boot properly from an installed hard disk so point the firmware boot manager to the right file.</p>

<h2 id="wait_grub">wait_grub</h2>

<pre><code>wait_grub([bootloader_time =&gt; $bootloader_time] [,in_grub =&gt; $in_grub]);</code></pre>

<p>Makes sure the bootloader appears. Returns successfully when reached the bootloader menu, ready to control it further or continue. The time waiting for the bootloader can be configured with <code>$bootloader_time</code> in seconds. Set <code>$in_grub</code> to 1 when the SUT is already expected to be within the grub menu.</p>

<h2 id="wait_grub_to_boot_on_local_disk">wait_grub_to_boot_on_local_disk</h2>

<pre><code>wait_grub_to_boot_on_local_disk</code></pre>

<p>When bootloader appears, make sure to boot from local disk when it is on aarch64.</p>

<h2 id="handle_pxeboot">handle_pxeboot</h2>

<pre><code>handle_pxeboot(bootloader_time =&gt; $bootloader_time, pxemenu =&gt; $pxemenu, pxeselect =&gt; $pxeselect);</code></pre>

<p>Handle a textmode PXE bootloader menu by means of two needle tags: <code>$pxemenu</code> to match the initial menu, <code>$pxeselect</code> to match the menu with the desired entry selected.</p>

<h2 id="wait_boot_past_bootloader">wait_boot_past_bootloader</h2>

<pre><code>wait_boot_past_bootloader([, textmode =&gt; $textmode] [,ready_time =&gt; $ready_time] [, nologin =&gt; $nologin] [, forcenologin =&gt; $forcenologin]);</code></pre>

<p>Waits until the system is booted, every step after the bootloader or bootloader menu. Returns successfully when the system is ready on a login prompt or logged in desktop. Set <code>$textmode</code> to 1 when the text mode login prompt should be expected rather than a desktop or display manager. Expects already unlocked encrypted disks, see <code>wait_boot</code> for handling these in before. The time waiting for the system to be fully booted can be configured with <code>$ready_time</code> in seconds. <code>$forcenologin</code> makes this function behave as if the env var NOAUTOLOGIN was set.</p>

<h2 id="wait_boot">wait_boot</h2>

<pre><code>wait_boot([bootloader_time =&gt; $bootloader_time] [, textmode =&gt; $textmode] [,ready_time =&gt; $ready_time] [,in_grub =&gt; $in_grub] [, nologin =&gt; $nologin] [, forcenologin =&gt; $forcenologin]);</code></pre>

<p>Makes sure the bootloader appears and then boots to desktop or text mode correspondingly. Returns successfully when the system is ready on a login prompt or logged in desktop. Set <code>$textmode</code> to 1 when the text mode login prompt should be expected rather than a desktop or display manager. <code>wait_boot</code> also handles unlocking encrypted disks if needed as well as various exceptions during the boot process. Also, before the bootloader menu or login prompt various architecture or machine specific handlings are in place. The time waiting for the bootloader can be configured with <code>$bootloader_time</code> in seconds as well as the time waiting for the system to be fully booted with <code>$ready_time</code> in seconds. Set <code>$in_grub</code> to 1 when the SUT is already expected to be within the grub menu. <code>wait_boot</code> continues from there. <code>$forcenologin</code> makes this function behave as if the env var NOAUTOLOGIN was set.</p>

<h2 id="enter_test_text">enter_test_text</h2>

<pre><code>enter_test_text($name [, cmd =&gt; $cmd] [, slow =&gt; $slow]);</code></pre>

<p>For testing a text editor or terminal emulator. This will type some newlines and then enter the following text:</p>

<pre><code>If you can see this text $name is working.</code></pre>

<p><code>$name</code> will default to &quot;<i>your program</i>&quot;. If <code>$slow</code> is set, the typing will be very slow. If <code>$cmd</code> is set, the text will be prefixed by an <code>echo</code> command.</p>

<h2 id="firewall">firewall</h2>

<pre><code>firewall();</code></pre>

<p>Return the default expected firewall implementation depending on the product under test, the version and if the SUT is an upgrade.</p>

<h2 id="post_fail_hook">post_fail_hook</h2>

<pre><code>post_fail_hook();</code></pre>

<p>When the test module fails, this method will be called. It will try to fetch some logs from the SUT. Test modules (or their intermediate base classes) may overwrite this method to export certain specific logfiles and call the base method using <code>$self-&gt;SUPER::post_fail_hook;</code> at the end.</p>


</body>

</html>


